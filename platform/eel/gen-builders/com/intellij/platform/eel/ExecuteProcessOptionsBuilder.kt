// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
/**
 * This file is generated by [com.intellij.platform.eel.codegen.BuildersGenerator].
 */
package com.intellij.platform.eel

import com.intellij.platform.eel.*
import com.intellij.platform.eel.EelExecApi.ExecuteProcessOptions
import com.intellij.platform.eel.EelExecApi.PtyOrStdErrSettings
import com.intellij.platform.eel.path.EelPath
import org.jetbrains.annotations.CheckReturnValue

/**
 * Executes the process, returning either an [EelProcess] or an error provided by the remote operating system.
 *
 * stdin, stdout and stderr of the process are always forwarded, if there are.
 *
 * The method may throw a RuntimeException only in critical cases like connection loss or a bug.
 *
 * See [executeProcessBuilder]
 *
 * @param exe An **absolute** path to the executable.
 *  TODO Or do relative paths also work?
 *
 *  All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
 *  [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
 */
@GeneratedBuilder.Result
fun EelExecApi.execute(
  exe: String,
): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder =
  com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder(
    owner = this,
    exe = exe,
  )

@GeneratedBuilder.Result
class com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder(
  private val owner: EelExecApi,
  private var exe: String,
) : OwnedBuilder<EelResult<EelProcess, EelExecApi.ExecuteProcessError>> {
  private var args: List<String> = listOf()

  private var env: Map<String, String> = mapOf()

  private var ptyOrStdErrSettings: PtyOrStdErrSettings? = null

  private var workingDirectory: EelPath? = null

  fun args(arg: List<String>): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder = apply {
    this.args = arg
  }

  fun args(vararg arg: String): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder = apply {
    this.args = listOf(*arg)
  }

  /**
   * By default, environment is always inherited, which may be unwanted. [ExecuteProcessOptions.env] allows
   * to alter some environment variables, it doesn't clear the variables from the parent. When the process should be started in an
   * environment like in a terminal, the response of [fetchLoginShellEnvVariables] should be put into [ExecuteProcessOptions.env].
   */
  fun env(arg: Map<String, String>): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder = apply {
    this.env = arg
  }

  /**
   * An **absolute** path to the executable.
   * TODO Or do relative paths also work?
   *
   * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
   * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
   */
  fun exe(arg: String): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder = apply {
    this.exe = arg
  }

  /**
   * When set pty, be sure to accept esc codes for a terminal you are emulating.
   * This terminal should also be set in `TERM` environment variable, so setting it in [env] worth doing.
   * If not set, `xterm` will be used as a most popular one.
   *
   * See `termcap(2)`, `terminfo(2)`, `ncurses(3X)` and ISBN `0937175226`.
   */
  fun ptyOrStdErrSettings(arg: PtyOrStdErrSettings?): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder = apply {
    this.ptyOrStdErrSettings = arg
  }

  /**
   * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
   * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
   */
  fun workingDirectory(arg: EelPath?): com_intellij_platform_eel_EelExecApi_execute_OwnedBuilder = apply {
    this.workingDirectory = arg
  }

  /**
   * Complete the builder and call [com.intellij.platform.eel.EelExecApi.execute]
   * with an instance of [com.intellij.platform.eel.EelExecApi.ExecuteProcessOptions].
   */
  @org.jetbrains.annotations.CheckReturnValue
  override suspend fun eelIt(): EelResult<EelProcess, EelExecApi.ExecuteProcessError> =
    owner.execute(
      ExecuteProcessOptionsImpl(
        args = args,
        env = env,
        exe = exe,
        ptyOrStdErrSettings = ptyOrStdErrSettings,
        workingDirectory = workingDirectory,
      )
    )
}

@GeneratedBuilder.Result
class ExecuteProcessOptionsBuilder(
  /**
   * An **absolute** path to the executable.
   * TODO Or do relative paths also work?
   *
   * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
   * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
   */
  private var exe: String,
) {
  private var args: List<String> = listOf()

  private var env: Map<String, String> = mapOf()

  private var ptyOrStdErrSettings: PtyOrStdErrSettings? = null

  private var workingDirectory: EelPath? = null

  fun args(arg: List<String>): ExecuteProcessOptionsBuilder = apply {
    this.args = arg
  }

  fun args(vararg arg: String): ExecuteProcessOptionsBuilder = apply {
    this.args = listOf(*arg)
  }

  /**
   * By default, environment is always inherited, which may be unwanted. [ExecuteProcessOptions.env] allows
   * to alter some environment variables, it doesn't clear the variables from the parent. When the process should be started in an
   * environment like in a terminal, the response of [fetchLoginShellEnvVariables] should be put into [ExecuteProcessOptions.env].
   */
  fun env(arg: Map<String, String>): ExecuteProcessOptionsBuilder = apply {
    this.env = arg
  }

  /**
   * An **absolute** path to the executable.
   * TODO Or do relative paths also work?
   *
   * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
   * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
   */
  fun exe(arg: String): ExecuteProcessOptionsBuilder = apply {
    this.exe = arg
  }

  /**
   * When set pty, be sure to accept esc codes for a terminal you are emulating.
   * This terminal should also be set in `TERM` environment variable, so setting it in [env] worth doing.
   * If not set, `xterm` will be used as a most popular one.
   *
   * See `termcap(2)`, `terminfo(2)`, `ncurses(3X)` and ISBN `0937175226`.
   */
  fun ptyOrStdErrSettings(arg: PtyOrStdErrSettings?): ExecuteProcessOptionsBuilder = apply {
    this.ptyOrStdErrSettings = arg
  }

  /**
   * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
   * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
   */
  fun workingDirectory(arg: EelPath?): ExecuteProcessOptionsBuilder = apply {
    this.workingDirectory = arg
  }

  fun build(): ExecuteProcessOptions =
    ExecuteProcessOptionsImpl(
      args = args,
      env = env,
      exe = exe,
      ptyOrStdErrSettings = ptyOrStdErrSettings,
      workingDirectory = workingDirectory,
    )
}

@GeneratedBuilder.Result
private class ExecuteProcessOptionsImpl(
  override val args: List<String>,
  override val env: Map<String, String>,
  override val exe: String,
  override val ptyOrStdErrSettings: PtyOrStdErrSettings?,
  override val workingDirectory: EelPath?,
) : ExecuteProcessOptions
      