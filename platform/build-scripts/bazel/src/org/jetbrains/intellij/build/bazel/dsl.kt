// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.bazel

import java.nio.file.Files
import java.nio.file.Path

internal fun buildFile(out: Path, block: BuildFile.() -> Unit) {
  val data = BuildFile().apply(block).render()
  if (runCatching { Files.readString(out) }.getOrNull() != data) {
    Files.writeString(out, data)
  }
}

internal fun buildFile(out: BazelFileUpdater, sectionName: String, block: BuildFile.() -> Unit) {
  out.insertAutoGeneratedSection(sectionName, BuildFile().apply(block).render())
}

private sealed interface Renderable {
  fun render(): String
}

internal class BuildFile {
  private val loads = mutableListOf<LoadStatement>()
  private val targets = mutableListOf<Target>()
  val lines = mutableListOf<String>()

  fun load(bzlFile: String, vararg symbols: String) {
    loads.add(LoadStatement(bzlFile, symbols.toList()))
  }

  // Generic target with arbitrary options
  fun target(type: String, block: Target.() -> Unit) {
    val target = Target(type).apply(block)
    targets.add(target)
  }

  fun render(): String {
    val loadStatements = loads.joinToString("\n") { it.render() }
    val targetStatements = targets.joinToString("\n") { it.render() }
    return sequenceOf(loadStatements, targetStatements, lines.joinToString("\n"))
      .filter { it.isNotEmpty() }
      .joinToString("\n\n")
  }
}

// Class to represent a load statement
internal class LoadStatement(private val bzlFile: String, private val symbols: List<String>) : Renderable {
  override fun render(): String {
    val formattedSymbols = symbols.joinToString(", ") { "\"$it\"" }
    return """load("$bzlFile", $formattedSymbols)"""
  }
}

internal class Target(private val type: String) : Renderable {
  private val attributes = mutableMapOf<String, Any>()

  // Support for setting key-value pairs with arrays
  fun option(key: String, value: Any) {
    attributes[key] = value
  }

  override fun render(): String {
    val renderedAttributes = attributes.map { (key, value) ->
      val formattedValue = when (value) {
        is List<*> -> value.joinToString(", ", "[", "]") { formatValue(it) }
        is Array<*> -> value.joinToString(", ", "[", "]") { formatValue(it) }
        else -> formatValue(value)
      }
      "  $key = $formattedValue"
    }.joinToString(",\n")

    return buildString {
      appendLine("$type(")
      appendLine(renderedAttributes)
      appendLine(")")
    }
  }

  private fun formatValue(value: Any?): String {
    return when (value) {
      is String -> "\"$value\""
      is Number -> value.toString()
      true -> "True"
      false -> "False"
      else -> value.toString()
    }
  }
}
