// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
@file:Suppress("SameParameterValue")

package org.jetbrains.intellij.build.bazel

import org.jetbrains.jps.model.java.*
import org.jetbrains.jps.model.library.JpsRepositoryLibraryType
import org.jetbrains.jps.model.module.JpsLibraryDependency
import org.jetbrains.jps.model.module.JpsModule
import org.jetbrains.jps.model.module.JpsModuleDependency
import org.jetbrains.jps.model.serialization.JpsSerializationManager
import org.jetbrains.jps.util.JpsPathUtil
import java.nio.file.Files
import java.nio.file.Path
import java.util.*
import kotlin.collections.ArrayDeque
import kotlin.io.path.invariantSeparatorsPathString

class JpsModuleToBazel {
  companion object {
    @JvmStatic
    fun main(args: Array<String>) {
      // App module - the module that we want to run. We build Bazel BUILD files for this module and all its dependencies.
      val m2Repo = Path.of(System.getProperty("user.name"), ".m2/repository")
      val projectDir = Path.of(".").toAbsolutePath().normalize()
      val project = JpsSerializationManager.getInstance().loadProject(projectDir.toString(), mapOf("MAVEN_REPOSITORY" to m2Repo.toString()), true)

      val nameToModule = project.model.project.modules.associateTo(HashMap()) { it.name to it }

      val generator = BazelBuildFileGenerator(projectDir)

      generator.addModuleToQueue(nameToModule.getValue("intellij.platform.buildScripts"))
      generator.addModuleToQueue(nameToModule.getValue("intellij.platform.buildScripts.bazel"))
      generator.generate()

      generateCommunityLibraryBuild(projectDir, generator)

      val bazelFileUpdater = BazelFileUpdater(projectDir.resolve("community/build/libraries/MODULE.bazel"))
      bazelFileUpdater.insertAutoGeneratedSection("artifacts", buildString {
        array(
          "artifacts",
          listOf("org.jetbrains.kotlin:kotlin-serialization-compiler-plugin:2.0.10")
          + generator.libs.asSequence().map { it.mavenCoordinates }.distinct().sorted().toList()
        )
      })
      bazelFileUpdater.save()
    }
  }
}

private fun generateCommunityLibraryBuild(projectDir: Path, generator: BazelBuildFileGenerator) {
  val bazelFileUpdater = BazelFileUpdater(projectDir.resolve("community/build/libraries/BUILD.bazel"))
  buildFile(bazelFileUpdater, "maven-libraries") {
    for (lib in generator.libs) {
      target("java_library") {
        option("name", lib.targetName)
        option("exports", arrayOf(lib.bazelPath))
        if (lib.isProvided) {
          @Suppress("SpellCheckingInspection")
          option("neverlink", true)
        }
        option("visibility", arrayOf("//visibility:public"))
      }
    }
  }
  bazelFileUpdater.save()
}

private data class ModuleDescriptor(
  @JvmField val contentRoot: Path,
)

private fun describeModule(module: JpsModule): ModuleDescriptor {
  val contentRoots = module.contentRootsList.urls.map { Path.of(JpsPathUtil.urlToPath(it)) }
  require(contentRoots.size == 1) {
    "Expected exactly one content root for module ${module.name}, got $contentRoots"
  }
  return ModuleDescriptor(
    contentRoot = contentRoots.first(),
  )
}

private data class Library(
  @JvmField val bazelPath: String,
  @JvmField val mavenCoordinates: String,
  @JvmField val targetName: String,
  @JvmField val isProvided: Boolean,
  @JvmField val isCommunity: Boolean,
)

private class BazelBuildFileGenerator(
  private val projectDir: Path,
  private val productionOnly: Boolean = true,
) {
  private val javaExtensionService = JpsJavaExtensionService.getInstance()

  private val generated = IdentityHashMap<JpsModule, Boolean>()
  private val queue = ArrayDeque<JpsModule>()

  private val moduleDescriptors = IdentityHashMap<JpsModule, ModuleDescriptor>()

  private fun getModuleDescriptor(module: JpsModule): ModuleDescriptor {
    return moduleDescriptors.computeIfAbsent(module) { describeModule(it) }
  }

  val libs = LinkedHashSet<Library>()

  fun addModuleToQueue(module: JpsModule) {
    if (generated.putIfAbsent(module, true) != null) {
      return
    }

    queue.addLast(module)
  }

  fun generate() {
    while (true) {
      generateBazelBuildFiles(module = queue.removeFirstOrNull() ?: break)
    }
  }

  private fun getBazelDepPath(module: JpsModule): String {
    val descriptor = getModuleDescriptor(module)
    val contentRoot = descriptor.contentRoot
    var path = checkAndGetRelativePath(projectDir, contentRoot).invariantSeparatorsPathString
    if (path.startsWith("community/")) {
      path = "@community//${path.removePrefix("community/")}"
    }
    else {
      path = "//$path"
    }
    return path + ":${module.name}"
  }

  private fun generateBazelBuildFiles(module: JpsModule) {
    val moduleDescriptor = getModuleDescriptor(module)
    val contentRoot = moduleDescriptor.contentRoot

    val sources = module.sourceRoots.asSequence()
      .filter { !productionOnly || JavaModuleSourceRootTypes.PRODUCTION.contains(it.rootType) }
      .joinToString(separator = ",") {
        var prefix = checkAndGetRelativePath(contentRoot, it.path).invariantSeparatorsPathString
        if (prefix.isNotEmpty()) {
          prefix += "/"
        }
        "'$prefix**/*.kt', '$prefix**/*.java'"
      }

    val deps = mutableListOf<String>()
    for (element in module.dependenciesList.dependencies) {
      val scope = javaExtensionService.getDependencyExtension(element)?.scope ?: continue
      if (productionOnly && !isProductionRuntime(withTests = false, scope = scope)) {
        continue
      }

      if (element is JpsModuleDependency) {
        val dependency = element.moduleReference.resolve()!!
        deps.add(getBazelDepPath(dependency))
        addModuleToQueue(dependency)
      }
      else if (element is JpsLibraryDependency) {
        val untypedLib = element.library!!
        val library = untypedLib.asTyped(JpsRepositoryLibraryType.INSTANCE)
        if (library == null) {
          val targetName = untypedLib.name.lowercase()
          deps.add("@community//lib:$targetName")
          continue
        }

        val data = library.properties.data
        val bazelPath = "@maven//:" + "${data.groupId}_${data.artifactId}".replace('.', '_').replace('-', '_')
        var isProvided = false
        var targetName = data.artifactId
        if (scope == JpsJavaDependencyScope.PROVIDED) {
          isProvided = true
          targetName += ".provided"
        }
        deps.add("@libraries//:$targetName")
        libs.add(
          Library(
            targetName = targetName,
            bazelPath = bazelPath,
            mavenCoordinates = "${data.groupId}:${data.artifactId}:${data.version}",
            isProvided = isProvided,
            // todo isCommunity
            isCommunity = true,
          )
        )
      }
    }

    val languageLevel = javaExtensionService.getLanguageLevel(module)
    val buildFile = StringBuilder()
    buildFile.appendLine("""load("@rules_kotlin//kotlin:jvm.bzl", "kt_jvm_library")""")
    buildFile.appendLine()
    buildFile.obj("kt_jvm_library") {
      buildFile.appendLine("""  visibility = ["//visibility:public"],""")
      buildFile.appendLine("""  name = "${module.name}",""")
      buildFile.appendLine("""  srcs = glob([$sources])""")

      var levelProfile: String? = "17"
      when {
        languageLevel == LanguageLevel.JDK_1_7 || languageLevel == LanguageLevel.JDK_1_8 -> levelProfile = "8"
        languageLevel == LanguageLevel.JDK_11 -> levelProfile = "11"
        languageLevel == LanguageLevel.JDK_17 -> levelProfile = "17"
        languageLevel != null -> error("Unsupported language level: $languageLevel")
      }

      if (levelProfile != null) {
        commaIfNeeded()
        line("""javac_opts = "//:j$levelProfile"""")
        line("""kotlinc_opts = "//:k$levelProfile"""")
      }

      line("""plugins = ["@libraries//:serialization_plugin"]""")

      if (deps.isNotEmpty()) {
        array("deps", deps)
      }
    }

    Files.writeString(contentRoot.resolve("BUILD.bazel"), buildFile)
  }

  private fun isProductionRuntime(withTests: Boolean, scope: JpsJavaDependencyScope): Boolean {
    if (withTests && scope.isIncludedIn(JpsJavaClasspathKind.TEST_RUNTIME)) {
      return true
    }
    return scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME) || scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE)
  }
}

private fun checkAndGetRelativePath(parentDir: Path, childDir: Path): Path {
  require(childDir.startsWith(parentDir)) {
    "$childDir must be a child of parentDir $parentDir"
  }
  return parentDir.relativize(childDir)
}